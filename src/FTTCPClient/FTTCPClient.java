package FTTCPClient;

import Utils.CryptoException;
import Utils.CryptoStuff;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.net.Socket;
import java.util.Arrays;


public class FTTCPClient {

    static final String KEYRING = "keyring";
    static final int BLOCKSIZE = 1024;

    /**
     * Gets the SecureKey
     *
     * @return key in keyring file generated by FTTCPClient.GenerateKey
     * @throws IOException
     */
    public static String getKey() throws IOException {
        File keyring = new File(KEYRING);
        return new String(Files.readAllBytes(keyring.toPath().toAbsolutePath()));
    }


    public static void main(String[] args) throws Exception {
        if (args.length != 3) {
            System.out.println("usage: java FTTCPClient host port filename");
            System.exit(0);
        }
        String server = args[0];
        int port = Integer.parseInt(args[1]);
        String filename = args[2];

        System.out.println("Sending: " + filename);


        // get inputFile
        FileInputStream f = new FileInputStream("src/FTTCPClient/" + filename);
        String key = getKey();

        // Cria uma conexao para o servidor
        Socket socket = new Socket(server, port);
        // Obtem o canal de escrita associado ao socket.
        OutputStream os = socket.getOutputStream();

        os.write(filename.getBytes()); // envia nome do ficheiro

        os.write(new byte[]{0}); // envia separador

        int n;
        byte[] buf = new byte[BLOCKSIZE];
        while ((n = f.read(buf)) > 0) { // copia o ficheiro para o servidor
            byte[] encryptedBuf = CryptoStuff.encrypt(key, buf);
            os.write(encryptedBuf, 0, n);
        }


        // Fecha o socket, quebrando a ligacao com o servidor.
        // (como consequencia tambem e' feito os.close() )
        socket.close();
        f.close();

        System.out.println("Done");
    }

}
